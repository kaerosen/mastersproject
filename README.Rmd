---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# tilemaps

<!-- badges: start -->
[![R build status](https://github.com/kaerosen/tilemaps/workflows/R-CMD-check/badge.svg)](https://github.com/kaerosen/tilemaps/actions)
<!-- badges: end -->

The `tilemaps` package implements an algorithm for generating maps, known as tile maps, in which each region is represented by a single tile of the same shape and size. When creating a tile map, the goal is to arrange tiles in a manner that preserves local relationships between regions, as well as the overall shape of the original map. The algorithm implemented in this package was proposed by Graham McNeill and Scott Hale in the paper *"Generating Tile Maps."* Using a tile map is advantageous when trying to visualize data where the importance of a region does not depend on the geographic area of the region. Tile maps prevent regions with large areas from dominating a map and prevent regions with small areas from going unnoticed. The package allows the user to generate a single tile map or many tile maps, which can be compared by using cost functions or by plotting the maps.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("kaerosen/tilemaps")
```

## Example

To create a single tile map, the `generate_map()` function can be used. In the following example, an `sf` object with a geometry list-column of class `sfc_MULTIPOLYGON` is loaded from the `spData` package. This data contains information on the contiguous United States. Washington, D.C. is filtered out of the data, and state abbreviations are added to the data to use when plotting the tile map. The coordinates are transformed from longitude and latitude to the mercator projection. Then the `generate_map()` function is used to create a tile map consisting of flat-topped hexagons. Details about the arguments of the `generate_map()` function can be found in the `tilemaps` vignette.

```{r single-map, message=FALSE}
library(tilemaps)
library(sf)
library(dplyr)
library(ggplot2)

us <- spData::us_states %>%
  filter(NAME != "District of Columbia") %>%
  arrange(NAME) %>%
  mutate(abbreviation = c("AL", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "ID",
                          "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI",
                          "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
                          "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN",
                          "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"))

us_3857 <- st_transform(us, 3857)

us_3857 <- us_3857 %>%
  mutate(tile_map = generate_map(geometry, square = FALSE, flat_topped = TRUE,
                                 prop = 0, interpolate = 1, smoothness = 0, shift = c(0,0)))

ggplot(us_3857) +
  geom_sf(aes(geometry = tile_map)) +
  geom_sf_text(aes(geometry = tile_map, label = abbreviation),
               fun.geometry = function(x) st_centroid(x))
```

Once a tile map has been created, coloring tiles according to another variable is simple. In the following code, a variable for the party of the governor of each state is added to the data frame, and then this variable is used to color the tiles.

```{r governor-map}
us_3857 <- us_3857 %>%
  mutate(party = c("R","R", "R", "D", "D", "D", "D", "R","R", "R", "D", "R", "R",
                   "D", "D", "D", "D", "R", "R", "D", "D", "R", "R", "D", "R", "D",
                   "R", "D", "D", "D", "D", "R","R", "R", "D", "D", "D", "R","R",
                   "R", "R","R", "R", "D", "D", "R", "D", "R"),
         party = ifelse(party == "R", "Republican", "Democrat"),
         party = factor(party, c("Republican", "Democrat")))

ggplot(us_3857) +
  geom_sf(aes(geometry = tile_map, fill = party)) +
  geom_sf_text(aes(geometry = tile_map, label = abbreviation),
               fun.geometry = function(x) st_centroid(x)) +
  ggtitle("Party Affiliation of United States Governors (2020)")
```

To create and compare more than one tile map, the `many_maps()` function can be used. For the `many_maps()` function, the `prop`, `interpolate`, `smoothness`, and `shift` arguments can take on multiple values, and the total number of maps generated by the `many_maps()` function is the product of the number of values each of these arguments can take on. In the following example, each of the arguments has two possible values, so 16 maps will be generated. The output of the `many_maps()` function is a data frame in which each row corresponds to one map and the columns contain the generated maps, the parameters used for creating the maps, and the costs associated with each map. The different types of costs are discussed in the `tilemaps` vignette as well. The `many_maps()` function can also automatically plot the generated maps, as is shown in this example.

```{r many-maps}
us_maps <- many_maps(us_3857$geometry, us_3857$abbreviation, prop = c(0, 0.1),
                     interpolate = c(0.5, 1), smoothness = c(0, 20), 
                     shift = list(c(0,0), c(0,0.5)), weights = c(1,1,1,1),
                     plot = TRUE, size = 1.5)
```

If the `plot` argument was set equal to `FALSE` when the many maps function was run, but a plot of all the generated maps is wanted, the `many_maps()` function does not need to be run again. Instead the `plot_many_maps()` function can be used to create the plot. Below is code for how the `plot_many_maps()` function can be used to create the same plot that was created when running the `many_maps()` function for the United States data previously.

```{r eval=FALSE}
plot_many_maps(us_maps$map, us_3857$abbreviation, size = 1.5)
```
