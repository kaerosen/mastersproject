---
title: "Tile Maps"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(mastersproject)
library(sf)
library(dplyr)
library(ggplot2)
```

# What is a Tile Map?

A tile map is a map in which each region is represented by a single tile of the same shape and size. For example, a square tile map of the United States would consist of square tiles of the same size for each state, regardless of the geographic area of each state. When creating a tile map, the goal is to arrange tiles in a manner that preserves local relationships between regions, as well as the overall shape of the original map. Using a tile map is advantageous when trying to visualize data where the importance of a region does not depend on the geographic area of the region. Tile maps prevent regions with large areas from dominating a map and prevent regions with small areas from going unnoticed. The `tilemaps` package implements an algorithm for creating tile maps that was proposed by Graham McNeill and Scott Hale in the paper *"Generating Tile Maps."* `tilemaps` allows the user to generate a single tile map or many tile maps, which can be compared by using cost functions or by plotting the maps.

# Creating a Single Tile Map

To create a single tile map, the `generate_map()` function can be used. This function requires an object of class `sfc_POLYGON` or `sfc_MULTIPOLYGON` as input. The `st_read()` function from the `sf` package can be used to read in a shapefile, and if the resulting geometry list-column is of class `sfc_POLYGON` or `sfc_MULTIPOLYGON`, then it can be passed to the `generate_map()` function to create a tile map. In the following example of creating a tile map, an `sf` object with a geometry list-column of class `sfc_MULTIPOLYGON` is loaded from the `spData` package. This data contains information on the contiguous United States. Washington, D.C. is filtered out of the data, and state abbreviations are added to the data to use when plotting the tile map. If the coordinates of the `sfc` object are in terms of longitude and latitude, the coordinates will need to be transformed to a planar projection before creating the tile map. The `st_transform()` function from the `sf` package can be used to transform the coordinates. In the following example, the mercator projection is used.

```{r}
us <- spData::us_states %>%
  filter(NAME != "District of Columbia") %>%
  arrange(NAME) %>%
  mutate(abbreviation = c("AL", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "ID",
                          "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI",
                          "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM", "NY",
                          "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN",
                          "TX", "UT", "VT", "VA", "WA", "WV", "WI", "WY"))

us_3857 <- st_transform(us, 3857)
```

Additional arguments can be passed to the `generate_map()` function to control various aspects of the resulting tile map. The `square` argument controls whether the tiles are squares or hexagons, and the `flat_topped` argument controls whether or not hexagons are flat-topped. The `prop`, `interpolate`, `smoothness`, and `shift` arguments control sources of variation in the algorithm that can lead to different final tile maps. How these arguments introduce variation will be discussed in detail later. The following code generates and plots a hexagon tile map of the United States.

```{r fig.height=3, fig.width=4, fig.align='center'}
us_3857 <- us_3857 %>%
  mutate(tile_map = generate_map(geometry, square = FALSE, flat_topped = TRUE,
                                 prop = 0, interpolate = 1, smoothness = 0, shift = c(0,0)))

ggplot(us_3857) +
  geom_sf(aes(geometry = tile_map)) +
  geom_sf_text(aes(geometry = tile_map, label = abbreviation),
               fun.geometry = function(x) st_centroid(x))
```

Once a tile map has been created, coloring tiles according to another variable is simple. In the following code, a variable for the party of the governor of each state is added to the data frame, and then this variable is used to color the tiles in the plot of the tile map. This is an example of a situation where it is useful to use a tile map, instead of a regular map, because each state has only one governor, regardless of the area or population of the state.

```{r fig.height=4.5, fig.width=5.5, fig.align='center'}
us_3857 <- us_3857 %>%
  mutate(party = c("R","R", "R", "D", "D", "D", "D", "R","R", "R", "D", "R", "R",
                   "D", "D", "D", "D", "R", "R", "D", "D", "R", "R", "D", "R", "D",
                   "R", "D", "D", "D", "D", "R","R", "R", "D", "D", "D", "R","R",
                   "R", "R","R", "R", "D", "D", "R", "D", "R"),
         party = ifelse(party == "R", "Republican", "Democrat"),
         party = factor(party, c("Republican", "Democrat")))

ggplot(us_3857) +
  geom_sf(aes(geometry = tile_map, fill = party)) +
  geom_sf_text(aes(geometry = tile_map, label = abbreviation),
               fun.geometry = function(x) st_centroid(x)) +
  ggtitle("Party Affiliation of United States Governors (2020)")
```

# Creating Many Tile Maps

To create and compare more than one tile map, the `many_maps()` function can be used. Similarly to the `generate_map()` function, the `many_maps()` function requires the data to be an object of class `sfc_POLYGON` or `sfc_MULTIPOLYGON`. Additionally, the `many_maps()` function has a `labels` argument which needs to be a character vector of the labels for the regions in the map. The `square` and `flat_topped` arguments are the same as for the `generate_map()` function. Again the `prop`, `interpolate`, `smoothness`, and `shift` arguments control sources of variation when creating the tile maps, but for the `many_maps()` function these arguments can have multiple values. The total number of maps generated by the `many_maps()` function is the product of the number of values each of these arguments can take on. In the following example, each of the `prop`, `interpolate`, `smoothness`, and `shift` arguments has two possible values, so 16 maps will be generated. The `weights` argument is used to control the `weights` used when calculating the total cost associated with each map. The different types of costs will be discussed later as well. The `plot` argument controls whether or not the generated maps should automatically be plotted, and the `size` argument controls the size of the labels in the plots. The output of the `many_maps()` function is a data frame in which each row corresponds to one map and the columns contain the generated maps, the parameters used for creating the maps, and the costs associated with each map. The data frame is ordered by the total cost.

```{r fig.height=6, fig.width=7, fig.align='center'}
us_maps <- many_maps(us_3857$geometry, us_3857$abbreviation, prop = c(0, 0.1),
                     interpolate = c(0.5, 1), smoothness = c(0, 20), 
                     shift = list(c(0,0), c(0,0.5)), weights = c(1,1,1,1),
                     plot = TRUE, size = 1.5)
```

After comparing the tile maps that were generated, the tile map that the user wishes to use can be added to the original data frame and plotted.

```{r fig.height=3, fig.width=4, fig.align='center'}
us_3857 <- us_3857 %>%
  mutate(square_map = us_maps$map[[1]])

ggplot(us_3857) +
  geom_sf(aes(geometry = square_map)) +
  geom_sf_text(aes(geometry = square_map, label = abbreviation))
```

If the `plot` argument was set equal to `FALSE` when the many maps function was run, but a plot of all the generated maps is wanted, the `many_maps()` function does not need to be run again. Instead the `plot_many_maps()` function can be used to create the plot that the `many_maps()` function would have if the `plot` argument were set equal to `TRUE`. The first argument required by the `plot_many_maps()` function is a list of maps, which are of class `sfc_POLYGON`. The map column from the data frame created by the `many_maps()` function can be supplied for the first argument. The labels for the regions must also be given as an argument to the `plot_many_maps()` function, and the `size` argument can be used to adjust the size of the labels in the plot. Below is code for how the `plot_many_maps()` function can be used to create the same plot that was created when running the `many_maps()` function for the United States data previously.

```{r eval=FALSE}
plot_many_maps(us_maps$map, us_3857$abbreviation, size = 1.5)
```

# The Algorithm

The four main steps of the algorithm used to generate a tile map are transforming the centroids, transforming the boundary, fitting tiles to the boundary, and assigning regions to tiles. The `prop`, `interpolate`, `smoothness`, and `shift` arguments of the `generate_map()` and `many_maps()` functions are used to introduce variation at different steps in the algorithm, which can lead to different candidate maps. How each step of the algorithm works and how variation is introduced will now be discussed in greater detail.

## Transforming the Centroids

The first step of the algorithm is to transform the region centroids so that centroids of neighboring regions are approximately equidistant but the relative orientation of neighbors is still preserved. The `prop` argument can be used at this step of the algorithm to add variation. Before transforming the original region centroids, Gaussian noise is added to the position of each centroid. The standard deviation for the Gaussian noise is defined as a proportion of the mean distance of a region centroid to its neighbor centroids, and the `prop` argument is used to control this proportion. After noise has been added to the centroids, the centroids are iteratively updated until they converge. The formula used to update the noisy centroids is given by McNeill and Hale in *"Generating Tile Maps."*

Before moving to the next step of the algorithm, another source of variation can be added. Throughout the remaining steps of the algorithm the fully-transformed centroids can be used, or interpolated centroids can be used. The interpolated centroids are defined through linear interpolation between the noisy centroids and fully-transformed centroids. If straight lines were drawn between the noisy centroids and fully-transformed centroids, then the interpolated centroids would be the points at a specified proportion of the distances along the lines. The `interpolate` argument controls the proportion. If the `interpolate` argument is set equal to 0, then the noisy centroids would be used in the remaining steps of the algorithm, and if the `interpolate` argument is set equal to 1, then the fully-transformed centroids would be used. If the `interpolate` argument is set equal to 0.75, then the points that are at 75% of the distance between the noisy centroids and fully-transformed centroids would be used.

Using the same United States dataset as before, the plot below shows the noisy, interpolated, and fully-transformed centroids when the `prop` argument was set equal to 0.1, and the `interpolate` argument was set equal to 0.75. Notice that in the plot the centroids of states in the northeast are being pushed out, while centroids of states on the west coast are being pulled toward the center of the map. This results in the centroids of neighboring states being approximately equidistant. Throughout the remaining steps of the algorithm, the interpolated centroids will be used.

```{r echo=FALSE, fig.height=5, fig.width=6, fig.align='center'}
neighbors <- sf::st_touches(us_3857$geometry)
crs <- sf::st_crs(us_3857$geometry)
R <- length(us_3857$geometry)
A <- sum(sf::st_area(us_3857$geometry))
s <- as.numeric(sqrt(A/R))

centroids <- transform_centroids(us_3857$geometry, neighbors, crs, s, prop = 0.1)

interpolated_centroids <- interpolate_centroids(centroids$noisy_centroids,
                                                centroids$transformed_centroids,
                                                crs, interpolate = 0.75)

centroids_df <- data.frame(sf::st_coordinates(c(centroids$noisy_centroids,
                                            centroids$transformed_centroids,
                                            interpolated_centroids)))
centroids_df <- centroids_df %>%
  mutate(centroids = c(rep("noisy", nrow(us_3857)), 
                       rep("fully-transformed", nrow(us_3857)),
                       rep("interpolated", nrow(us_3857))),
         region = rep(us_3857$abbreviation, 3))

ggplot() +
  geom_sf(aes(geometry = us_3857$geometry)) +
  geom_point(data = centroids_df, aes(X, Y, color = centroids)) +
  geom_line(data = centroids_df, aes(X,Y, group = region)) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())
```

## Transforming the Boundary

The next step of the algorithm is to transform the boundary of the map based on the new centroids. The boundary is pulled in toward the new centroids if the boundary is more than the estimated tile size away from the centroids, and the boundary is pushed away from the new centroids if the boundary is less than the estimated tile size away from the centroids. At this step, the boundary of the map is first converted to a set of points, and then a sample of approximately 1,000 points is taken from that set. The sampled boundary points are transformed according to the formula given in *"Generating Tile Maps."* After the sample boundary points have been transformed, they are then converted to a polygon. To introduce variation at this step in the algorithm, the transformed boundary can be smoothed. The `smooth()` function from the `smoothr` package is used to perform kernel smoothing of the boundary. How much the boundary is smoothed is controlled by the `smoothness` argument. The `smooth()` function calculates the bandwidth of the Gaussian kernel used for smoothing as the mean distance between adjacent points, and the bandwidth is then multiplied by the value given for the `smoothness` argument. The greater the value of the `smoothness` argument, the more smooth the boundary will become. Below is a plot with the transformed and smoothed boundaries of the United States with the `smoothness` argument set equal to 20. Notice that the transformed boundary is now outside the original boundary around the northeast and the transformed boundary is within the original boundary along the west coast. For the remaining steps of the algorithm, the smoothed boundary will be used.

```{r echo=FALSE, fig.height=4, fig.width=5, fig.align='center'}
transformed_boundary <- transform_boundary(us_3857$geometry, centroids$noisy_centroids,
                                           interpolated_centroids)
smoothed_boundary <- smoothr::smooth(transformed_boundary, method = "ksmooth",
                                     smoothness = 20)

ggplot() +
  geom_sf(aes(geometry = us_3857$geometry)) +
  geom_sf(aes(geometry = sf::st_boundary(transformed_boundary), color = "transformed")) +
  geom_sf(aes(geometry = sf::st_boundary(smoothed_boundary), color = "smoothed")) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank()) +
  scale_color_discrete(name = "boundary")
```

## Fitting Tiles to the Boundary

The third step of the algorithm is to fit tiles inside the transformed boundary. This is done by first creating a grid of tiles that covers the bounding box of the transformed polygon. The size of the tiles is estimated by first finding the total area of the map, dividing it by the number of regions, and then taking the square root. After creating the initial grid, the number of tile centroids that are inside the transformed boundary is found. Depending on whether the number of tile centroids inside the boundary is greater than or less than the number of regions in the map, the tile size is either increased or decreased, and then a new grid of tiles is created. This process is repeated until the correct number of tile centroids are within the transformed boundary. Variation can also be added at this step by shifting the grid of tiles before counting the number of tile centroids that lie within the transformed boundary. The `shift` argument is a numeric vector of length two for the `generate_map()` function or a list of numeric vectors of length two for the `many_maps()` function. The first value of the vector determines the amount to shift in the x direction and the second value determines the amount to shift in the y direction. The values given in the vector are multiplied by the tile size, and the resulting value is the amount that the grid is shifted. For example if `c(0.5,0.5)` was given for the shift argument in the `generate_map()` function, then the grid of tiles would be shifted by half a tile in both the x and y directions. In the final step of the algorithm, a square grid, which was shifted by half a tile in each direction, will be used.

```{r echo=FALSE}
tiles <- fit_tiles(smoothed_boundary, nrow(us_3857), s, shift = c(0.5,0.5))
```

## Assigning Regions to Tiles

To complete the tile map, the regions of the original map must be assigned to the tiles of the tile map. The assignment of regions to tiles is chosen to minimize the sum of the squared distances between transformed region centroids and the assigned tile centroids. This an example of the well-known linear sum assignment problem. This problem can be solved using an algorithm known as the Hungarian method, which was first developed by Harold Kuhn. A plot of the resulting tile map is shown below.

```{r echo=FALSE, fig.height=3, fig.width=4, fig.align='center'}
permutation <- assign_regions(interpolated_centroids, sf::st_centroid(tiles))
final_map <- tiles[order(permutation)]

us_3857 <- us_3857 %>%
  mutate(map = final_map)

ggplot(us_3857) +
  geom_sf(aes(geometry = map)) +
  geom_sf_text(aes(geometry = map, label = abbreviation))
```

## Calculating Costs

In *"Generating Tile Maps,"* McNeill and Hale describe four different cost functions that can be used to compare tile maps. The first is a location cost, which is the mean distance between the transformed centroids and tile centroids divided by the tile size. The next cost is an adjacency cost, which is the mean of the proportion of neighbors that each region is missing. The relative orientation cost is a measure of how much the angles between centroids of neighboring regions change. First the mean change in angles between a region centroid and its neighboring centroids is found for each region. The final adjacency cost is the mean of the means of the regions. The final cost is a roughness cost. This cost is based on how many edges in the tile map are shared edges. These four costs can be combined into one total cost as a weighted sum. The data frame output by the `many_maps()` function includes columns for each of the costs, and the `weights` argument can be used to control the weight for each cost when calculating the total cost.  



