---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(mastersproject)
```

# What is a Tile Map?

A tile map is a map in which each region is represented by a single tile of the same shape and size. For example, a square tile map of the United States would consist of square tiles of the same size for each state, regardless of the area of each state. When creating a tile map, the goal is to arrange tiles in a manner that preserves local relationships between regions, as well as the overall shape of the original map. Using a tile map is advantageous when trying to visualize data where the importance of a region does not depend on the area of the region. Tile maps prevent regions with large areas from dominating a map and prevent regions with small areas from going unnoticed. The `packagename` package implements an algorithm for creating tile maps that was proposed by Graham McNeill and Scott Hale in the paper *"Generating Tile Maps."* `packagename` allows the user to generate a single tile map or many tile maps, which can be compared by using cost functions or by plotting the maps.

# Creating a Single Tile Map

To create a single tile map, the `generate_map()` function can be used. This function requires an object of class `sfc_POLYGON` or `sfc_MULTIPOLYGON` as input. The `st_read()` function from the `sf` package can be used to read in a shapefile, and if the resulting geometry list-column is of class `sfc_POLYGON` or `sfc_MULTIPOLYGON`, then it can be passed to the `generate_map()` function to create a tile map. In the following example of creating a tile map, an `sf` object with a geometry list-column of class `sfc_MULTIPOLYGON` is loaded from the `spData` package. This data contains information on the contiguous United States. State abbreviations are added to the data to use when plotting the tile map. If the coordinates of the `sfc` object are in terms of longitude and latitude, the coordinates will need to be transformed to a planar projection before creating the tile map. The `st_transform()` function from the `sf` package can be used to transform the coordinates. In the following example, the mercator projection is used.

```{r}
us <- spData::us_states %>%
  arrange(NAME) %>%
  mutate(abbreviation = c("AL", "AZ", "AR", "CA", "CO", "CT", "DE", "DC", "FL", "GA",
                          "ID", "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", 
                          "MI", "MN", "MS", "MO", "MT", "NE", "NV", "NH", "NJ", "NM",
                          "NY", "NC", "ND", "OH", "OK", "OR", "PA", "RI", "SC", "SD",
                          "TN", "TX", "UT", "VE", "VA", "WA", "WV", "WI", "WY"))

us_3857 <- st_transform(us, 3857)
```

Additional arguments can be passed to the `generate_map()` function to control various aspects of the resulting tile map. The square argument controls whether the tiles are squares or hexagons, and the flat_topped argument controls whether or not hexagons are flat-topped. The prop, interpolate, smoothness, and shift arguments control sources of variation in the algorithm that can lead to different final tile maps. How these arguments introduce variation will be discussed in detail later. The following code generates and plots a hexagon tile map of the United States.

```{r}
us_3857 <- us_3857 %>%
  mutate(tile_map = generate_map(geometry, square = FALSE, flat_topped = TRUE,
                                 prop = 0, interpolate = 1, smoothness = 0, shift = c(0,0)))

ggplot(us_3857) +
  geom_sf(aes(geometry = tile_map)) +
  geom_sf_text(aes(geometry = tile_map, label = abbreviation),
               fun.geometry = function(x) sf::st_centroid(x))
```

# Creating Many Tile Maps

To create and compare more than one tile map, the `many_maps()` function can be used. Similarly to the `generate_map()` function, the `many_maps()` function requires the data to be an object of class `sfc_POLYGON` or `sfc_MULTIPOLYGON`. Additionally, the `many_maps()` function has a labels argument which needs to be a character vector of the labels for the regions in the map. The square and flat_topped arguments are the same as for the `generate_map()` function. Again the prop, interpolate, smoothness, and shift arguments control sources of variation when creating the tile maps, but for the `many_maps()` function these arguments can have multiple values. The total number of maps generated by the `many_maps()` function is the product of the number of values each of these arguments can take on. In the following example, each of the prop, interpolate, smoothness, and shift arguments has two possible values, so 16 maps will be generated. The weights argument is used to control the weights used when calculating the total cost associated with each map. The different types of costs will be discussed later as well. The plot argument controls whether or not the generated maps should automatically be plotted, and the size argument controls the size of the labels in the plots. The output of the `many_maps()` function is a data frame which contains the generated maps, the parameters used for creating the maps, and the costs associated with each map. The data frame is ordered by the total cost.

```{r}
us_maps <- many_maps(us_3857$geometry, us_3857$abbreviation, prop = c(0, 0.1), interpolate = c(0.5, 1),
                     smoothness = c(0, 20), shift = list(c(0,0), c(0,0.5)), weights = c(1,1,1,1),
                     plot = TRUE)
```

After comparing the tile maps that were generated, the tile map that the user wishes to use can be added to the original data frame and plotted.

```{r}
us_3857 <- us_3857 %>%
  mutate(square_map = us_maps$map[[1]])

ggplot(us_3857) +
  geom_sf(aes(geometry = square_map)) +
  geom_sf_text(aes(geometry = square_map, label = abbreviation))
```

If the plot argument was set equal to `FALSE` when the many maps function was run, but a plot of all the generated maps is wanted, the `many_maps()` function does not need to be run again. Instead the `plot_many_maps()` function can be used to create the plot that the `many_maps()` function would have if the plot argument were set equal to `TRUE`. The first argument required by the `plot_many_maps()` function is a list of maps, which are of class `sfc_POLYGON`. The map column from the data frame created by the `many_maps()` function can be supplied for the first argument. The labels for the regions must also be given as an argument to the `plot_many_maps()` function, and the size argument can be used to adjust the size of the labels in the plot. Below, the `plot_many_maps()` function is used to create the same plot that was created when running the `many_maps()` function for the United States data previously.

```{r}
plot_many_maps(us_maps$map, us_3857$abbreviation)
```

# The Algorithm

## Transforming the Centroids

## Transforming the Boundary

## Fitting Tiles to the Boundary

## Assigning Regions to Tiles

## Calculating Costs
